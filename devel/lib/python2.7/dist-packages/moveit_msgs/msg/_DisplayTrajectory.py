"""autogenerated by genpy from moveit_msgs/DisplayTrajectory.msg. Do not edit."""
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import trajectory_msgs.msg
import geometry_msgs.msg
import shape_msgs.msg
import moveit_msgs.msg
import object_recognition_msgs.msg
import sensor_msgs.msg
import genpy
import std_msgs.msg

class DisplayTrajectory(genpy.Message):
  _md5sum = "c3c039261ab9e8a11457dac56b6316c8"
  _type = "moveit_msgs/DisplayTrajectory"
  _has_header = False #flag to mark the presence of a Header object
  _full_text = """# The model id for which this path has been generated
string model_id

# The representation of the path contains position values for all the joints that are moving along the path; a sequence of trajectories may be specified
RobotTrajectory[] trajectory

# The robot state is used to obtain positions for all/some of the joints of the robot. 
# It is used by the path display node to determine the positions of the joints that are not specified in the joint path message above. 
# If the robot state message contains joint position information for joints that are also mentioned in the joint path message, the positions in the joint path message will overwrite the positions specified in the robot state message. 
RobotState trajectory_start

================================================================================
MSG: moveit_msgs/RobotTrajectory
trajectory_msgs/JointTrajectory joint_trajectory
trajectory_msgs/MultiDOFJointTrajectory multi_dof_joint_trajectory

================================================================================
MSG: trajectory_msgs/JointTrajectory
Header header
string[] joint_names
JointTrajectoryPoint[] points
================================================================================
MSG: std_msgs/Header
# Standard metadata for higher-level stamped data types.
# This is generally used to communicate timestamped data 
# in a particular coordinate frame.
# 
# sequence ID: consecutively increasing ID 
uint32 seq
#Two-integer timestamp that is expressed as:
# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')
# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')
# time-handling sugar is provided by the client library
time stamp
#Frame this data is associated with
# 0: no frame
# 1: global frame
string frame_id

================================================================================
MSG: trajectory_msgs/JointTrajectoryPoint
# Each trajectory point specifies either positions[, velocities[, accelerations]]
# or positions[, effort] for the trajectory to be executed.
# All specified values are in the same order as the joint names in JointTrajectory.msg

float64[] positions
float64[] velocities
float64[] accelerations
float64[] effort
duration time_from_start

================================================================================
MSG: trajectory_msgs/MultiDOFJointTrajectory
# The header is used to specify the coordinate frame and the reference time for the trajectory durations
Header header

# A representation of a multi-dof joint trajectory (each point is a transformation)
# Each point along the trajectory will include an array of positions/velocities/accelerations
# that has the same length as the array of joint names, and has the same order of joints as 
# the joint names array.

string[] joint_names
MultiDOFJointTrajectoryPoint[] points

================================================================================
MSG: trajectory_msgs/MultiDOFJointTrajectoryPoint
# Each multi-dof joint can specify a transform (up to 6 DOF)
geometry_msgs/Transform[] transforms

# There can be a velocity specified for the origin of the joint 
geometry_msgs/Twist[] velocities

# There can be an acceleration specified for the origin of the joint 
geometry_msgs/Twist[] accelerations

duration time_from_start

================================================================================
MSG: geometry_msgs/Transform
# This represents the transform between two coordinate frames in free space.

Vector3 translation
Quaternion rotation

================================================================================
MSG: geometry_msgs/Vector3
# This represents a vector in free space. 

float64 x
float64 y
float64 z
================================================================================
MSG: geometry_msgs/Quaternion
# This represents an orientation in free space in quaternion form.

float64 x
float64 y
float64 z
float64 w

================================================================================
MSG: geometry_msgs/Twist
# This expresses velocity in free space broken into its linear and angular parts.
Vector3  linear
Vector3  angular

================================================================================
MSG: moveit_msgs/RobotState
# This message contains information about the robot state, i.e. the positions of its joints and links
sensor_msgs/JointState joint_state

# Joints that may have multiple DOF are specified here
sensor_msgs/MultiDOFJointState multi_dof_joint_state

# Attached collision objects (attached to some link on the robot)
AttachedCollisionObject[] attached_collision_objects

# Flag indicating whether this scene is to be interpreted as a diff with respect to some other scene
# This is mostly important for handling the attached bodies (whether or not to clear the attached bodies
# of a moveit::core::RobotState before updating it with this message)
bool is_diff

================================================================================
MSG: sensor_msgs/JointState
# This is a message that holds data to describe the state of a set of torque controlled joints. 
#
# The state of each joint (revolute or prismatic) is defined by:
#  * the position of the joint (rad or m),
#  * the velocity of the joint (rad/s or m/s) and 
#  * the effort that is applied in the joint (Nm or N).
#
# Each joint is uniquely identified by its name
# The header specifies the time at which the joint states were recorded. All the joint states
# in one message have to be recorded at the same time.
#
# This message consists of a multiple arrays, one for each part of the joint state. 
# The goal is to make each of the fields optional. When e.g. your joints have no
# effort associated with them, you can leave the effort array empty. 
#
# All arrays in this message should have the same size, or be empty.
# This is the only way to uniquely associate the joint name with the correct
# states.


Header header

string[] name
float64[] position
float64[] velocity
float64[] effort

================================================================================
MSG: sensor_msgs/MultiDOFJointState
# Representation of state for joints with multiple degrees of freedom, 
# following the structure of JointState.
#
# It is assumed that a joint in a system corresponds to a transform that gets applied 
# along the kinematic chain. For example, a planar joint (as in URDF) is 3DOF (x, y, yaw)
# and those 3DOF can be expressed as a transformation matrix, and that transformation
# matrix can be converted back to (x, y, yaw)
#
# Each joint is uniquely identified by its name
# The header specifies the time at which the joint states were recorded. All the joint states
# in one message have to be recorded at the same time.
#
# This message consists of a multiple arrays, one for each part of the joint state. 
# The goal is to make each of the fields optional. When e.g. your joints have no
# wrench associated with them, you can leave the wrench array empty. 
#
# All arrays in this message should have the same size, or be empty.
# This is the only way to uniquely associate the joint name with the correct
# states.

Header header

string[] joint_names
geometry_msgs/Transform[] transforms
geometry_msgs/Twist[] twist
geometry_msgs/Wrench[] wrench

================================================================================
MSG: geometry_msgs/Wrench
# This represents force in free space, separated into
# its linear and angular parts.
Vector3  force
Vector3  torque

================================================================================
MSG: moveit_msgs/AttachedCollisionObject
# The CollisionObject will be attached with a fixed joint to this link
string link_name

#This contains the actual shapes and poses for the CollisionObject
#to be attached to the link
#If action is remove and no object.id is set, all objects
#attached to the link indicated by link_name will be removed
CollisionObject object

# The set of links that the attached objects are allowed to touch
# by default - the link_name is already considered by default
string[] touch_links

# If certain links were placed in a particular posture for this object to remain attached 
# (e.g., an end effector closing around an object), the posture necessary for releasing
# the object is stored here
trajectory_msgs/JointTrajectory detach_posture

# The weight of the attached object, if known
float64 weight

================================================================================
MSG: moveit_msgs/CollisionObject
# a header, used for interpreting the poses
Header header

# the id of the object (name used in MoveIt)
string id

# The object type in a database of known objects
object_recognition_msgs/ObjectType type

# the the collision geometries associated with the object;
# their poses are with respect to the specified header

# solid geometric primitives
shape_msgs/SolidPrimitive[] primitives
geometry_msgs/Pose[] primitive_poses

# meshes
shape_msgs/Mesh[] meshes
geometry_msgs/Pose[] mesh_poses

# bounding planes (equation is specified, but the plane can be oriented using an additional pose)
shape_msgs/Plane[] planes
geometry_msgs/Pose[] plane_poses

# Adds the object to the planning scene. If the object previously existed, it is replaced.
byte ADD=0

# Removes the object from the environment entirely (everything that matches the specified id)
byte REMOVE=1

# Append to an object that already exists in the planning scene. If the does not exist, it is added.
byte APPEND=2

# If an object already exists in the scene, new poses can be sent (the geometry arrays must be left empty)
# if solely moving the object is desired
byte MOVE=3

# Operation to be performed
byte operation

================================================================================
MSG: object_recognition_msgs/ObjectType
################################################## OBJECT ID #########################################################

# Contains information about the type of a found object. Those two sets of parameters together uniquely define an
# object

# The key of the found object: the unique identifier in the given db
string key

# The db parameters stored as a JSON/compressed YAML string. An object id does not make sense without the corresponding
# database. E.g., in object_recognition, it can look like: "{'type':'CouchDB', 'root':'http://localhost'}"
# There is no conventional format for those parameters and it's nice to keep that flexibility.
# The object_recognition_core as a generic DB type that can read those fields
# Current examples:
# For CouchDB:
#   type: 'CouchDB'
#   root: 'http://localhost:5984'
#   collection: 'object_recognition'
# For SQL household database:
#   type: 'SqlHousehold'
#   host: 'wgs36'
#   port: 5432
#   user: 'willow'
#   password: 'willow'
#   name: 'household_objects'
#   module: 'tabletop'
string db

================================================================================
MSG: shape_msgs/SolidPrimitive
# Define box, sphere, cylinder, cone 
# All shapes are defined to have their bounding boxes centered around 0,0,0.

uint8 BOX=1
uint8 SPHERE=2
uint8 CYLINDER=3
uint8 CONE=4

# The type of the shape
uint8 type


# The dimensions of the shape
float64[] dimensions

# The meaning of the shape dimensions: each constant defines the index in the 'dimensions' array

# For the BOX type, the X, Y, and Z dimensions are the length of the corresponding
# sides of the box.
uint8 BOX_X=0
uint8 BOX_Y=1
uint8 BOX_Z=2


# For the SPHERE type, only one component is used, and it gives the radius of
# the sphere.
uint8 SPHERE_RADIUS=0


# For the CYLINDER and CONE types, the center line is oriented along
# the Z axis.  Therefore the CYLINDER_HEIGHT (CONE_HEIGHT) component
# of dimensions gives the height of the cylinder (cone).  The
# CYLINDER_RADIUS (CONE_RADIUS) component of dimensions gives the
# radius of the base of the cylinder (cone).  Cone and cylinder
# primitives are defined to be circular. The tip of the cone is
# pointing up, along +Z axis.

uint8 CYLINDER_HEIGHT=0
uint8 CYLINDER_RADIUS=1

uint8 CONE_HEIGHT=0
uint8 CONE_RADIUS=1

================================================================================
MSG: geometry_msgs/Pose
# A representation of pose in free space, composed of postion and orientation. 
Point position
Quaternion orientation

================================================================================
MSG: geometry_msgs/Point
# This contains the position of a point in free space
float64 x
float64 y
float64 z

================================================================================
MSG: shape_msgs/Mesh
# Definition of a mesh

# list of triangles; the index values refer to positions in vertices[]
MeshTriangle[] triangles

# the actual vertices that make up the mesh
geometry_msgs/Point[] vertices

================================================================================
MSG: shape_msgs/MeshTriangle
# Definition of a triangle's vertices
uint32[3] vertex_indices

================================================================================
MSG: shape_msgs/Plane
# Representation of a plane, using the plane equation ax + by + cz + d = 0

# a := coef[0]
# b := coef[1]
# c := coef[2]
# d := coef[3]

float64[4] coef

"""
  __slots__ = ['model_id','trajectory','trajectory_start']
  _slot_types = ['string','moveit_msgs/RobotTrajectory[]','moveit_msgs/RobotState']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       model_id,trajectory,trajectory_start

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(DisplayTrajectory, self).__init__(*args, **kwds)
      #message fields cannot be None, assign default values for those that are
      if self.model_id is None:
        self.model_id = ''
      if self.trajectory is None:
        self.trajectory = []
      if self.trajectory_start is None:
        self.trajectory_start = moveit_msgs.msg.RobotState()
    else:
      self.model_id = ''
      self.trajectory = []
      self.trajectory_start = moveit_msgs.msg.RobotState()

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self.model_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      if python3:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
      length = len(self.trajectory)
      buff.write(_struct_I.pack(length))
      for val1 in self.trajectory:
        _v1 = val1.joint_trajectory
        _v2 = _v1.header
        buff.write(_struct_I.pack(_v2.seq))
        _v3 = _v2.stamp
        _x = _v3
        buff.write(_struct_2I.pack(_x.secs, _x.nsecs))
        _x = _v2.frame_id
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        if python3:
          buff.write(struct.pack('<I%sB'%length, length, *_x))
        else:
          buff.write(struct.pack('<I%ss'%length, length, _x))
        length = len(_v1.joint_names)
        buff.write(_struct_I.pack(length))
        for val3 in _v1.joint_names:
          length = len(val3)
          if python3 or type(val3) == unicode:
            val3 = val3.encode('utf-8')
            length = len(val3)
          if python3:
            buff.write(struct.pack('<I%sB'%length, length, *val3))
          else:
            buff.write(struct.pack('<I%ss'%length, length, val3))
        length = len(_v1.points)
        buff.write(_struct_I.pack(length))
        for val3 in _v1.points:
          length = len(val3.positions)
          buff.write(_struct_I.pack(length))
          pattern = '<%sd'%length
          buff.write(struct.pack(pattern, *val3.positions))
          length = len(val3.velocities)
          buff.write(_struct_I.pack(length))
          pattern = '<%sd'%length
          buff.write(struct.pack(pattern, *val3.velocities))
          length = len(val3.accelerations)
          buff.write(_struct_I.pack(length))
          pattern = '<%sd'%length
          buff.write(struct.pack(pattern, *val3.accelerations))
          length = len(val3.effort)
          buff.write(_struct_I.pack(length))
          pattern = '<%sd'%length
          buff.write(struct.pack(pattern, *val3.effort))
          _v4 = val3.time_from_start
          _x = _v4
          buff.write(_struct_2i.pack(_x.secs, _x.nsecs))
        _v5 = val1.multi_dof_joint_trajectory
        _v6 = _v5.header
        buff.write(_struct_I.pack(_v6.seq))
        _v7 = _v6.stamp
        _x = _v7
        buff.write(_struct_2I.pack(_x.secs, _x.nsecs))
        _x = _v6.frame_id
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        if python3:
          buff.write(struct.pack('<I%sB'%length, length, *_x))
        else:
          buff.write(struct.pack('<I%ss'%length, length, _x))
        length = len(_v5.joint_names)
        buff.write(_struct_I.pack(length))
        for val3 in _v5.joint_names:
          length = len(val3)
          if python3 or type(val3) == unicode:
            val3 = val3.encode('utf-8')
            length = len(val3)
          if python3:
            buff.write(struct.pack('<I%sB'%length, length, *val3))
          else:
            buff.write(struct.pack('<I%ss'%length, length, val3))
        length = len(_v5.points)
        buff.write(_struct_I.pack(length))
        for val3 in _v5.points:
          length = len(val3.transforms)
          buff.write(_struct_I.pack(length))
          for val4 in val3.transforms:
            _v8 = val4.translation
            _x = _v8
            buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
            _v9 = val4.rotation
            _x = _v9
            buff.write(_struct_4d.pack(_x.x, _x.y, _x.z, _x.w))
          length = len(val3.velocities)
          buff.write(_struct_I.pack(length))
          for val4 in val3.velocities:
            _v10 = val4.linear
            _x = _v10
            buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
            _v11 = val4.angular
            _x = _v11
            buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
          length = len(val3.accelerations)
          buff.write(_struct_I.pack(length))
          for val4 in val3.accelerations:
            _v12 = val4.linear
            _x = _v12
            buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
            _v13 = val4.angular
            _x = _v13
            buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
          _v14 = val3.time_from_start
          _x = _v14
          buff.write(_struct_2i.pack(_x.secs, _x.nsecs))
      _x = self
      buff.write(_struct_3I.pack(_x.trajectory_start.joint_state.header.seq, _x.trajectory_start.joint_state.header.stamp.secs, _x.trajectory_start.joint_state.header.stamp.nsecs))
      _x = self.trajectory_start.joint_state.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      if python3:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
      length = len(self.trajectory_start.joint_state.name)
      buff.write(_struct_I.pack(length))
      for val1 in self.trajectory_start.joint_state.name:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        if python3:
          buff.write(struct.pack('<I%sB'%length, length, *val1))
        else:
          buff.write(struct.pack('<I%ss'%length, length, val1))
      length = len(self.trajectory_start.joint_state.position)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.trajectory_start.joint_state.position))
      length = len(self.trajectory_start.joint_state.velocity)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.trajectory_start.joint_state.velocity))
      length = len(self.trajectory_start.joint_state.effort)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.trajectory_start.joint_state.effort))
      _x = self
      buff.write(_struct_3I.pack(_x.trajectory_start.multi_dof_joint_state.header.seq, _x.trajectory_start.multi_dof_joint_state.header.stamp.secs, _x.trajectory_start.multi_dof_joint_state.header.stamp.nsecs))
      _x = self.trajectory_start.multi_dof_joint_state.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      if python3:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
      length = len(self.trajectory_start.multi_dof_joint_state.joint_names)
      buff.write(_struct_I.pack(length))
      for val1 in self.trajectory_start.multi_dof_joint_state.joint_names:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        if python3:
          buff.write(struct.pack('<I%sB'%length, length, *val1))
        else:
          buff.write(struct.pack('<I%ss'%length, length, val1))
      length = len(self.trajectory_start.multi_dof_joint_state.transforms)
      buff.write(_struct_I.pack(length))
      for val1 in self.trajectory_start.multi_dof_joint_state.transforms:
        _v15 = val1.translation
        _x = _v15
        buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
        _v16 = val1.rotation
        _x = _v16
        buff.write(_struct_4d.pack(_x.x, _x.y, _x.z, _x.w))
      length = len(self.trajectory_start.multi_dof_joint_state.twist)
      buff.write(_struct_I.pack(length))
      for val1 in self.trajectory_start.multi_dof_joint_state.twist:
        _v17 = val1.linear
        _x = _v17
        buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
        _v18 = val1.angular
        _x = _v18
        buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
      length = len(self.trajectory_start.multi_dof_joint_state.wrench)
      buff.write(_struct_I.pack(length))
      for val1 in self.trajectory_start.multi_dof_joint_state.wrench:
        _v19 = val1.force
        _x = _v19
        buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
        _v20 = val1.torque
        _x = _v20
        buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
      length = len(self.trajectory_start.attached_collision_objects)
      buff.write(_struct_I.pack(length))
      for val1 in self.trajectory_start.attached_collision_objects:
        _x = val1.link_name
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        if python3:
          buff.write(struct.pack('<I%sB'%length, length, *_x))
        else:
          buff.write(struct.pack('<I%ss'%length, length, _x))
        _v21 = val1.object
        _v22 = _v21.header
        buff.write(_struct_I.pack(_v22.seq))
        _v23 = _v22.stamp
        _x = _v23
        buff.write(_struct_2I.pack(_x.secs, _x.nsecs))
        _x = _v22.frame_id
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        if python3:
          buff.write(struct.pack('<I%sB'%length, length, *_x))
        else:
          buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = _v21.id
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        if python3:
          buff.write(struct.pack('<I%sB'%length, length, *_x))
        else:
          buff.write(struct.pack('<I%ss'%length, length, _x))
        _v24 = _v21.type
        _x = _v24.key
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        if python3:
          buff.write(struct.pack('<I%sB'%length, length, *_x))
        else:
          buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = _v24.db
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        if python3:
          buff.write(struct.pack('<I%sB'%length, length, *_x))
        else:
          buff.write(struct.pack('<I%ss'%length, length, _x))
        length = len(_v21.primitives)
        buff.write(_struct_I.pack(length))
        for val3 in _v21.primitives:
          buff.write(_struct_B.pack(val3.type))
          length = len(val3.dimensions)
          buff.write(_struct_I.pack(length))
          pattern = '<%sd'%length
          buff.write(struct.pack(pattern, *val3.dimensions))
        length = len(_v21.primitive_poses)
        buff.write(_struct_I.pack(length))
        for val3 in _v21.primitive_poses:
          _v25 = val3.position
          _x = _v25
          buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
          _v26 = val3.orientation
          _x = _v26
          buff.write(_struct_4d.pack(_x.x, _x.y, _x.z, _x.w))
        length = len(_v21.meshes)
        buff.write(_struct_I.pack(length))
        for val3 in _v21.meshes:
          length = len(val3.triangles)
          buff.write(_struct_I.pack(length))
          for val4 in val3.triangles:
            buff.write(_struct_3I.pack(*val4.vertex_indices))
          length = len(val3.vertices)
          buff.write(_struct_I.pack(length))
          for val4 in val3.vertices:
            _x = val4
            buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
        length = len(_v21.mesh_poses)
        buff.write(_struct_I.pack(length))
        for val3 in _v21.mesh_poses:
          _v27 = val3.position
          _x = _v27
          buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
          _v28 = val3.orientation
          _x = _v28
          buff.write(_struct_4d.pack(_x.x, _x.y, _x.z, _x.w))
        length = len(_v21.planes)
        buff.write(_struct_I.pack(length))
        for val3 in _v21.planes:
          buff.write(_struct_4d.pack(*val3.coef))
        length = len(_v21.plane_poses)
        buff.write(_struct_I.pack(length))
        for val3 in _v21.plane_poses:
          _v29 = val3.position
          _x = _v29
          buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
          _v30 = val3.orientation
          _x = _v30
          buff.write(_struct_4d.pack(_x.x, _x.y, _x.z, _x.w))
        buff.write(_struct_b.pack(_v21.operation))
        length = len(val1.touch_links)
        buff.write(_struct_I.pack(length))
        for val2 in val1.touch_links:
          length = len(val2)
          if python3 or type(val2) == unicode:
            val2 = val2.encode('utf-8')
            length = len(val2)
          if python3:
            buff.write(struct.pack('<I%sB'%length, length, *val2))
          else:
            buff.write(struct.pack('<I%ss'%length, length, val2))
        _v31 = val1.detach_posture
        _v32 = _v31.header
        buff.write(_struct_I.pack(_v32.seq))
        _v33 = _v32.stamp
        _x = _v33
        buff.write(_struct_2I.pack(_x.secs, _x.nsecs))
        _x = _v32.frame_id
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        if python3:
          buff.write(struct.pack('<I%sB'%length, length, *_x))
        else:
          buff.write(struct.pack('<I%ss'%length, length, _x))
        length = len(_v31.joint_names)
        buff.write(_struct_I.pack(length))
        for val3 in _v31.joint_names:
          length = len(val3)
          if python3 or type(val3) == unicode:
            val3 = val3.encode('utf-8')
            length = len(val3)
          if python3:
            buff.write(struct.pack('<I%sB'%length, length, *val3))
          else:
            buff.write(struct.pack('<I%ss'%length, length, val3))
        length = len(_v31.points)
        buff.write(_struct_I.pack(length))
        for val3 in _v31.points:
          length = len(val3.positions)
          buff.write(_struct_I.pack(length))
          pattern = '<%sd'%length
          buff.write(struct.pack(pattern, *val3.positions))
          length = len(val3.velocities)
          buff.write(_struct_I.pack(length))
          pattern = '<%sd'%length
          buff.write(struct.pack(pattern, *val3.velocities))
          length = len(val3.accelerations)
          buff.write(_struct_I.pack(length))
          pattern = '<%sd'%length
          buff.write(struct.pack(pattern, *val3.accelerations))
          length = len(val3.effort)
          buff.write(_struct_I.pack(length))
          pattern = '<%sd'%length
          buff.write(struct.pack(pattern, *val3.effort))
          _v34 = val3.time_from_start
          _x = _v34
          buff.write(_struct_2i.pack(_x.secs, _x.nsecs))
        buff.write(_struct_d.pack(val1.weight))
      buff.write(_struct_B.pack(self.trajectory_start.is_diff))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(_x))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(_x))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    try:
      if self.trajectory is None:
        self.trajectory = None
      if self.trajectory_start is None:
        self.trajectory_start = moveit_msgs.msg.RobotState()
      end = 0
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.model_id = str[start:end].decode('utf-8')
      else:
        self.model_id = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.trajectory = []
      for i in range(0, length):
        val1 = moveit_msgs.msg.RobotTrajectory()
        _v35 = val1.joint_trajectory
        _v36 = _v35.header
        start = end
        end += 4
        (_v36.seq,) = _struct_I.unpack(str[start:end])
        _v37 = _v36.stamp
        _x = _v37
        start = end
        end += 8
        (_x.secs, _x.nsecs,) = _struct_2I.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v36.frame_id = str[start:end].decode('utf-8')
        else:
          _v36.frame_id = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v35.joint_names = []
        for i in range(0, length):
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val3 = str[start:end].decode('utf-8')
          else:
            val3 = str[start:end]
          _v35.joint_names.append(val3)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v35.points = []
        for i in range(0, length):
          val3 = trajectory_msgs.msg.JointTrajectoryPoint()
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          pattern = '<%sd'%length
          start = end
          end += struct.calcsize(pattern)
          val3.positions = struct.unpack(pattern, str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          pattern = '<%sd'%length
          start = end
          end += struct.calcsize(pattern)
          val3.velocities = struct.unpack(pattern, str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          pattern = '<%sd'%length
          start = end
          end += struct.calcsize(pattern)
          val3.accelerations = struct.unpack(pattern, str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          pattern = '<%sd'%length
          start = end
          end += struct.calcsize(pattern)
          val3.effort = struct.unpack(pattern, str[start:end])
          _v38 = val3.time_from_start
          _x = _v38
          start = end
          end += 8
          (_x.secs, _x.nsecs,) = _struct_2i.unpack(str[start:end])
          _v35.points.append(val3)
        _v39 = val1.multi_dof_joint_trajectory
        _v40 = _v39.header
        start = end
        end += 4
        (_v40.seq,) = _struct_I.unpack(str[start:end])
        _v41 = _v40.stamp
        _x = _v41
        start = end
        end += 8
        (_x.secs, _x.nsecs,) = _struct_2I.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v40.frame_id = str[start:end].decode('utf-8')
        else:
          _v40.frame_id = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v39.joint_names = []
        for i in range(0, length):
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val3 = str[start:end].decode('utf-8')
          else:
            val3 = str[start:end]
          _v39.joint_names.append(val3)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v39.points = []
        for i in range(0, length):
          val3 = trajectory_msgs.msg.MultiDOFJointTrajectoryPoint()
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          val3.transforms = []
          for i in range(0, length):
            val4 = geometry_msgs.msg.Transform()
            _v42 = val4.translation
            _x = _v42
            start = end
            end += 24
            (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
            _v43 = val4.rotation
            _x = _v43
            start = end
            end += 32
            (_x.x, _x.y, _x.z, _x.w,) = _struct_4d.unpack(str[start:end])
            val3.transforms.append(val4)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          val3.velocities = []
          for i in range(0, length):
            val4 = geometry_msgs.msg.Twist()
            _v44 = val4.linear
            _x = _v44
            start = end
            end += 24
            (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
            _v45 = val4.angular
            _x = _v45
            start = end
            end += 24
            (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
            val3.velocities.append(val4)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          val3.accelerations = []
          for i in range(0, length):
            val4 = geometry_msgs.msg.Twist()
            _v46 = val4.linear
            _x = _v46
            start = end
            end += 24
            (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
            _v47 = val4.angular
            _x = _v47
            start = end
            end += 24
            (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
            val3.accelerations.append(val4)
          _v48 = val3.time_from_start
          _x = _v48
          start = end
          end += 8
          (_x.secs, _x.nsecs,) = _struct_2i.unpack(str[start:end])
          _v39.points.append(val3)
        self.trajectory.append(val1)
      _x = self
      start = end
      end += 12
      (_x.trajectory_start.joint_state.header.seq, _x.trajectory_start.joint_state.header.stamp.secs, _x.trajectory_start.joint_state.header.stamp.nsecs,) = _struct_3I.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.trajectory_start.joint_state.header.frame_id = str[start:end].decode('utf-8')
      else:
        self.trajectory_start.joint_state.header.frame_id = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.trajectory_start.joint_state.name = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8')
        else:
          val1 = str[start:end]
        self.trajectory_start.joint_state.name.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.trajectory_start.joint_state.position = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.trajectory_start.joint_state.velocity = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.trajectory_start.joint_state.effort = struct.unpack(pattern, str[start:end])
      _x = self
      start = end
      end += 12
      (_x.trajectory_start.multi_dof_joint_state.header.seq, _x.trajectory_start.multi_dof_joint_state.header.stamp.secs, _x.trajectory_start.multi_dof_joint_state.header.stamp.nsecs,) = _struct_3I.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.trajectory_start.multi_dof_joint_state.header.frame_id = str[start:end].decode('utf-8')
      else:
        self.trajectory_start.multi_dof_joint_state.header.frame_id = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.trajectory_start.multi_dof_joint_state.joint_names = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8')
        else:
          val1 = str[start:end]
        self.trajectory_start.multi_dof_joint_state.joint_names.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.trajectory_start.multi_dof_joint_state.transforms = []
      for i in range(0, length):
        val1 = geometry_msgs.msg.Transform()
        _v49 = val1.translation
        _x = _v49
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
        _v50 = val1.rotation
        _x = _v50
        start = end
        end += 32
        (_x.x, _x.y, _x.z, _x.w,) = _struct_4d.unpack(str[start:end])
        self.trajectory_start.multi_dof_joint_state.transforms.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.trajectory_start.multi_dof_joint_state.twist = []
      for i in range(0, length):
        val1 = geometry_msgs.msg.Twist()
        _v51 = val1.linear
        _x = _v51
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
        _v52 = val1.angular
        _x = _v52
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
        self.trajectory_start.multi_dof_joint_state.twist.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.trajectory_start.multi_dof_joint_state.wrench = []
      for i in range(0, length):
        val1 = geometry_msgs.msg.Wrench()
        _v53 = val1.force
        _x = _v53
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
        _v54 = val1.torque
        _x = _v54
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
        self.trajectory_start.multi_dof_joint_state.wrench.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.trajectory_start.attached_collision_objects = []
      for i in range(0, length):
        val1 = moveit_msgs.msg.AttachedCollisionObject()
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.link_name = str[start:end].decode('utf-8')
        else:
          val1.link_name = str[start:end]
        _v55 = val1.object
        _v56 = _v55.header
        start = end
        end += 4
        (_v56.seq,) = _struct_I.unpack(str[start:end])
        _v57 = _v56.stamp
        _x = _v57
        start = end
        end += 8
        (_x.secs, _x.nsecs,) = _struct_2I.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v56.frame_id = str[start:end].decode('utf-8')
        else:
          _v56.frame_id = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v55.id = str[start:end].decode('utf-8')
        else:
          _v55.id = str[start:end]
        _v58 = _v55.type
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v58.key = str[start:end].decode('utf-8')
        else:
          _v58.key = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v58.db = str[start:end].decode('utf-8')
        else:
          _v58.db = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v55.primitives = []
        for i in range(0, length):
          val3 = shape_msgs.msg.SolidPrimitive()
          start = end
          end += 1
          (val3.type,) = _struct_B.unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          pattern = '<%sd'%length
          start = end
          end += struct.calcsize(pattern)
          val3.dimensions = struct.unpack(pattern, str[start:end])
          _v55.primitives.append(val3)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v55.primitive_poses = []
        for i in range(0, length):
          val3 = geometry_msgs.msg.Pose()
          _v59 = val3.position
          _x = _v59
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
          _v60 = val3.orientation
          _x = _v60
          start = end
          end += 32
          (_x.x, _x.y, _x.z, _x.w,) = _struct_4d.unpack(str[start:end])
          _v55.primitive_poses.append(val3)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v55.meshes = []
        for i in range(0, length):
          val3 = shape_msgs.msg.Mesh()
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          val3.triangles = []
          for i in range(0, length):
            val4 = shape_msgs.msg.MeshTriangle()
            start = end
            end += 12
            val4.vertex_indices = _struct_3I.unpack(str[start:end])
            val3.triangles.append(val4)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          val3.vertices = []
          for i in range(0, length):
            val4 = geometry_msgs.msg.Point()
            _x = val4
            start = end
            end += 24
            (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
            val3.vertices.append(val4)
          _v55.meshes.append(val3)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v55.mesh_poses = []
        for i in range(0, length):
          val3 = geometry_msgs.msg.Pose()
          _v61 = val3.position
          _x = _v61
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
          _v62 = val3.orientation
          _x = _v62
          start = end
          end += 32
          (_x.x, _x.y, _x.z, _x.w,) = _struct_4d.unpack(str[start:end])
          _v55.mesh_poses.append(val3)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v55.planes = []
        for i in range(0, length):
          val3 = shape_msgs.msg.Plane()
          start = end
          end += 32
          val3.coef = _struct_4d.unpack(str[start:end])
          _v55.planes.append(val3)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v55.plane_poses = []
        for i in range(0, length):
          val3 = geometry_msgs.msg.Pose()
          _v63 = val3.position
          _x = _v63
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
          _v64 = val3.orientation
          _x = _v64
          start = end
          end += 32
          (_x.x, _x.y, _x.z, _x.w,) = _struct_4d.unpack(str[start:end])
          _v55.plane_poses.append(val3)
        start = end
        end += 1
        (_v55.operation,) = _struct_b.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.touch_links = []
        for i in range(0, length):
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val2 = str[start:end].decode('utf-8')
          else:
            val2 = str[start:end]
          val1.touch_links.append(val2)
        _v65 = val1.detach_posture
        _v66 = _v65.header
        start = end
        end += 4
        (_v66.seq,) = _struct_I.unpack(str[start:end])
        _v67 = _v66.stamp
        _x = _v67
        start = end
        end += 8
        (_x.secs, _x.nsecs,) = _struct_2I.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v66.frame_id = str[start:end].decode('utf-8')
        else:
          _v66.frame_id = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v65.joint_names = []
        for i in range(0, length):
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val3 = str[start:end].decode('utf-8')
          else:
            val3 = str[start:end]
          _v65.joint_names.append(val3)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v65.points = []
        for i in range(0, length):
          val3 = trajectory_msgs.msg.JointTrajectoryPoint()
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          pattern = '<%sd'%length
          start = end
          end += struct.calcsize(pattern)
          val3.positions = struct.unpack(pattern, str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          pattern = '<%sd'%length
          start = end
          end += struct.calcsize(pattern)
          val3.velocities = struct.unpack(pattern, str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          pattern = '<%sd'%length
          start = end
          end += struct.calcsize(pattern)
          val3.accelerations = struct.unpack(pattern, str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          pattern = '<%sd'%length
          start = end
          end += struct.calcsize(pattern)
          val3.effort = struct.unpack(pattern, str[start:end])
          _v68 = val3.time_from_start
          _x = _v68
          start = end
          end += 8
          (_x.secs, _x.nsecs,) = _struct_2i.unpack(str[start:end])
          _v65.points.append(val3)
        start = end
        end += 8
        (val1.weight,) = _struct_d.unpack(str[start:end])
        self.trajectory_start.attached_collision_objects.append(val1)
      start = end
      end += 1
      (self.trajectory_start.is_diff,) = _struct_B.unpack(str[start:end])
      self.trajectory_start.is_diff = bool(self.trajectory_start.is_diff)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e) #most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self.model_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      if python3:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
      length = len(self.trajectory)
      buff.write(_struct_I.pack(length))
      for val1 in self.trajectory:
        _v69 = val1.joint_trajectory
        _v70 = _v69.header
        buff.write(_struct_I.pack(_v70.seq))
        _v71 = _v70.stamp
        _x = _v71
        buff.write(_struct_2I.pack(_x.secs, _x.nsecs))
        _x = _v70.frame_id
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        if python3:
          buff.write(struct.pack('<I%sB'%length, length, *_x))
        else:
          buff.write(struct.pack('<I%ss'%length, length, _x))
        length = len(_v69.joint_names)
        buff.write(_struct_I.pack(length))
        for val3 in _v69.joint_names:
          length = len(val3)
          if python3 or type(val3) == unicode:
            val3 = val3.encode('utf-8')
            length = len(val3)
          if python3:
            buff.write(struct.pack('<I%sB'%length, length, *val3))
          else:
            buff.write(struct.pack('<I%ss'%length, length, val3))
        length = len(_v69.points)
        buff.write(_struct_I.pack(length))
        for val3 in _v69.points:
          length = len(val3.positions)
          buff.write(_struct_I.pack(length))
          pattern = '<%sd'%length
          buff.write(val3.positions.tostring())
          length = len(val3.velocities)
          buff.write(_struct_I.pack(length))
          pattern = '<%sd'%length
          buff.write(val3.velocities.tostring())
          length = len(val3.accelerations)
          buff.write(_struct_I.pack(length))
          pattern = '<%sd'%length
          buff.write(val3.accelerations.tostring())
          length = len(val3.effort)
          buff.write(_struct_I.pack(length))
          pattern = '<%sd'%length
          buff.write(val3.effort.tostring())
          _v72 = val3.time_from_start
          _x = _v72
          buff.write(_struct_2i.pack(_x.secs, _x.nsecs))
        _v73 = val1.multi_dof_joint_trajectory
        _v74 = _v73.header
        buff.write(_struct_I.pack(_v74.seq))
        _v75 = _v74.stamp
        _x = _v75
        buff.write(_struct_2I.pack(_x.secs, _x.nsecs))
        _x = _v74.frame_id
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        if python3:
          buff.write(struct.pack('<I%sB'%length, length, *_x))
        else:
          buff.write(struct.pack('<I%ss'%length, length, _x))
        length = len(_v73.joint_names)
        buff.write(_struct_I.pack(length))
        for val3 in _v73.joint_names:
          length = len(val3)
          if python3 or type(val3) == unicode:
            val3 = val3.encode('utf-8')
            length = len(val3)
          if python3:
            buff.write(struct.pack('<I%sB'%length, length, *val3))
          else:
            buff.write(struct.pack('<I%ss'%length, length, val3))
        length = len(_v73.points)
        buff.write(_struct_I.pack(length))
        for val3 in _v73.points:
          length = len(val3.transforms)
          buff.write(_struct_I.pack(length))
          for val4 in val3.transforms:
            _v76 = val4.translation
            _x = _v76
            buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
            _v77 = val4.rotation
            _x = _v77
            buff.write(_struct_4d.pack(_x.x, _x.y, _x.z, _x.w))
          length = len(val3.velocities)
          buff.write(_struct_I.pack(length))
          for val4 in val3.velocities:
            _v78 = val4.linear
            _x = _v78
            buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
            _v79 = val4.angular
            _x = _v79
            buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
          length = len(val3.accelerations)
          buff.write(_struct_I.pack(length))
          for val4 in val3.accelerations:
            _v80 = val4.linear
            _x = _v80
            buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
            _v81 = val4.angular
            _x = _v81
            buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
          _v82 = val3.time_from_start
          _x = _v82
          buff.write(_struct_2i.pack(_x.secs, _x.nsecs))
      _x = self
      buff.write(_struct_3I.pack(_x.trajectory_start.joint_state.header.seq, _x.trajectory_start.joint_state.header.stamp.secs, _x.trajectory_start.joint_state.header.stamp.nsecs))
      _x = self.trajectory_start.joint_state.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      if python3:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
      length = len(self.trajectory_start.joint_state.name)
      buff.write(_struct_I.pack(length))
      for val1 in self.trajectory_start.joint_state.name:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        if python3:
          buff.write(struct.pack('<I%sB'%length, length, *val1))
        else:
          buff.write(struct.pack('<I%ss'%length, length, val1))
      length = len(self.trajectory_start.joint_state.position)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.trajectory_start.joint_state.position.tostring())
      length = len(self.trajectory_start.joint_state.velocity)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.trajectory_start.joint_state.velocity.tostring())
      length = len(self.trajectory_start.joint_state.effort)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.trajectory_start.joint_state.effort.tostring())
      _x = self
      buff.write(_struct_3I.pack(_x.trajectory_start.multi_dof_joint_state.header.seq, _x.trajectory_start.multi_dof_joint_state.header.stamp.secs, _x.trajectory_start.multi_dof_joint_state.header.stamp.nsecs))
      _x = self.trajectory_start.multi_dof_joint_state.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      if python3:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
      length = len(self.trajectory_start.multi_dof_joint_state.joint_names)
      buff.write(_struct_I.pack(length))
      for val1 in self.trajectory_start.multi_dof_joint_state.joint_names:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        if python3:
          buff.write(struct.pack('<I%sB'%length, length, *val1))
        else:
          buff.write(struct.pack('<I%ss'%length, length, val1))
      length = len(self.trajectory_start.multi_dof_joint_state.transforms)
      buff.write(_struct_I.pack(length))
      for val1 in self.trajectory_start.multi_dof_joint_state.transforms:
        _v83 = val1.translation
        _x = _v83
        buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
        _v84 = val1.rotation
        _x = _v84
        buff.write(_struct_4d.pack(_x.x, _x.y, _x.z, _x.w))
      length = len(self.trajectory_start.multi_dof_joint_state.twist)
      buff.write(_struct_I.pack(length))
      for val1 in self.trajectory_start.multi_dof_joint_state.twist:
        _v85 = val1.linear
        _x = _v85
        buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
        _v86 = val1.angular
        _x = _v86
        buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
      length = len(self.trajectory_start.multi_dof_joint_state.wrench)
      buff.write(_struct_I.pack(length))
      for val1 in self.trajectory_start.multi_dof_joint_state.wrench:
        _v87 = val1.force
        _x = _v87
        buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
        _v88 = val1.torque
        _x = _v88
        buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
      length = len(self.trajectory_start.attached_collision_objects)
      buff.write(_struct_I.pack(length))
      for val1 in self.trajectory_start.attached_collision_objects:
        _x = val1.link_name
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        if python3:
          buff.write(struct.pack('<I%sB'%length, length, *_x))
        else:
          buff.write(struct.pack('<I%ss'%length, length, _x))
        _v89 = val1.object
        _v90 = _v89.header
        buff.write(_struct_I.pack(_v90.seq))
        _v91 = _v90.stamp
        _x = _v91
        buff.write(_struct_2I.pack(_x.secs, _x.nsecs))
        _x = _v90.frame_id
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        if python3:
          buff.write(struct.pack('<I%sB'%length, length, *_x))
        else:
          buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = _v89.id
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        if python3:
          buff.write(struct.pack('<I%sB'%length, length, *_x))
        else:
          buff.write(struct.pack('<I%ss'%length, length, _x))
        _v92 = _v89.type
        _x = _v92.key
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        if python3:
          buff.write(struct.pack('<I%sB'%length, length, *_x))
        else:
          buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = _v92.db
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        if python3:
          buff.write(struct.pack('<I%sB'%length, length, *_x))
        else:
          buff.write(struct.pack('<I%ss'%length, length, _x))
        length = len(_v89.primitives)
        buff.write(_struct_I.pack(length))
        for val3 in _v89.primitives:
          buff.write(_struct_B.pack(val3.type))
          length = len(val3.dimensions)
          buff.write(_struct_I.pack(length))
          pattern = '<%sd'%length
          buff.write(val3.dimensions.tostring())
        length = len(_v89.primitive_poses)
        buff.write(_struct_I.pack(length))
        for val3 in _v89.primitive_poses:
          _v93 = val3.position
          _x = _v93
          buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
          _v94 = val3.orientation
          _x = _v94
          buff.write(_struct_4d.pack(_x.x, _x.y, _x.z, _x.w))
        length = len(_v89.meshes)
        buff.write(_struct_I.pack(length))
        for val3 in _v89.meshes:
          length = len(val3.triangles)
          buff.write(_struct_I.pack(length))
          for val4 in val3.triangles:
            buff.write(val4.vertex_indices.tostring())
          length = len(val3.vertices)
          buff.write(_struct_I.pack(length))
          for val4 in val3.vertices:
            _x = val4
            buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
        length = len(_v89.mesh_poses)
        buff.write(_struct_I.pack(length))
        for val3 in _v89.mesh_poses:
          _v95 = val3.position
          _x = _v95
          buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
          _v96 = val3.orientation
          _x = _v96
          buff.write(_struct_4d.pack(_x.x, _x.y, _x.z, _x.w))
        length = len(_v89.planes)
        buff.write(_struct_I.pack(length))
        for val3 in _v89.planes:
          buff.write(val3.coef.tostring())
        length = len(_v89.plane_poses)
        buff.write(_struct_I.pack(length))
        for val3 in _v89.plane_poses:
          _v97 = val3.position
          _x = _v97
          buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
          _v98 = val3.orientation
          _x = _v98
          buff.write(_struct_4d.pack(_x.x, _x.y, _x.z, _x.w))
        buff.write(_struct_b.pack(_v89.operation))
        length = len(val1.touch_links)
        buff.write(_struct_I.pack(length))
        for val2 in val1.touch_links:
          length = len(val2)
          if python3 or type(val2) == unicode:
            val2 = val2.encode('utf-8')
            length = len(val2)
          if python3:
            buff.write(struct.pack('<I%sB'%length, length, *val2))
          else:
            buff.write(struct.pack('<I%ss'%length, length, val2))
        _v99 = val1.detach_posture
        _v100 = _v99.header
        buff.write(_struct_I.pack(_v100.seq))
        _v101 = _v100.stamp
        _x = _v101
        buff.write(_struct_2I.pack(_x.secs, _x.nsecs))
        _x = _v100.frame_id
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        if python3:
          buff.write(struct.pack('<I%sB'%length, length, *_x))
        else:
          buff.write(struct.pack('<I%ss'%length, length, _x))
        length = len(_v99.joint_names)
        buff.write(_struct_I.pack(length))
        for val3 in _v99.joint_names:
          length = len(val3)
          if python3 or type(val3) == unicode:
            val3 = val3.encode('utf-8')
            length = len(val3)
          if python3:
            buff.write(struct.pack('<I%sB'%length, length, *val3))
          else:
            buff.write(struct.pack('<I%ss'%length, length, val3))
        length = len(_v99.points)
        buff.write(_struct_I.pack(length))
        for val3 in _v99.points:
          length = len(val3.positions)
          buff.write(_struct_I.pack(length))
          pattern = '<%sd'%length
          buff.write(val3.positions.tostring())
          length = len(val3.velocities)
          buff.write(_struct_I.pack(length))
          pattern = '<%sd'%length
          buff.write(val3.velocities.tostring())
          length = len(val3.accelerations)
          buff.write(_struct_I.pack(length))
          pattern = '<%sd'%length
          buff.write(val3.accelerations.tostring())
          length = len(val3.effort)
          buff.write(_struct_I.pack(length))
          pattern = '<%sd'%length
          buff.write(val3.effort.tostring())
          _v102 = val3.time_from_start
          _x = _v102
          buff.write(_struct_2i.pack(_x.secs, _x.nsecs))
        buff.write(_struct_d.pack(val1.weight))
      buff.write(_struct_B.pack(self.trajectory_start.is_diff))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(_x))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(_x))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    try:
      if self.trajectory is None:
        self.trajectory = None
      if self.trajectory_start is None:
        self.trajectory_start = moveit_msgs.msg.RobotState()
      end = 0
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.model_id = str[start:end].decode('utf-8')
      else:
        self.model_id = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.trajectory = []
      for i in range(0, length):
        val1 = moveit_msgs.msg.RobotTrajectory()
        _v103 = val1.joint_trajectory
        _v104 = _v103.header
        start = end
        end += 4
        (_v104.seq,) = _struct_I.unpack(str[start:end])
        _v105 = _v104.stamp
        _x = _v105
        start = end
        end += 8
        (_x.secs, _x.nsecs,) = _struct_2I.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v104.frame_id = str[start:end].decode('utf-8')
        else:
          _v104.frame_id = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v103.joint_names = []
        for i in range(0, length):
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val3 = str[start:end].decode('utf-8')
          else:
            val3 = str[start:end]
          _v103.joint_names.append(val3)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v103.points = []
        for i in range(0, length):
          val3 = trajectory_msgs.msg.JointTrajectoryPoint()
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          pattern = '<%sd'%length
          start = end
          end += struct.calcsize(pattern)
          val3.positions = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          pattern = '<%sd'%length
          start = end
          end += struct.calcsize(pattern)
          val3.velocities = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          pattern = '<%sd'%length
          start = end
          end += struct.calcsize(pattern)
          val3.accelerations = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          pattern = '<%sd'%length
          start = end
          end += struct.calcsize(pattern)
          val3.effort = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
          _v106 = val3.time_from_start
          _x = _v106
          start = end
          end += 8
          (_x.secs, _x.nsecs,) = _struct_2i.unpack(str[start:end])
          _v103.points.append(val3)
        _v107 = val1.multi_dof_joint_trajectory
        _v108 = _v107.header
        start = end
        end += 4
        (_v108.seq,) = _struct_I.unpack(str[start:end])
        _v109 = _v108.stamp
        _x = _v109
        start = end
        end += 8
        (_x.secs, _x.nsecs,) = _struct_2I.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v108.frame_id = str[start:end].decode('utf-8')
        else:
          _v108.frame_id = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v107.joint_names = []
        for i in range(0, length):
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val3 = str[start:end].decode('utf-8')
          else:
            val3 = str[start:end]
          _v107.joint_names.append(val3)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v107.points = []
        for i in range(0, length):
          val3 = trajectory_msgs.msg.MultiDOFJointTrajectoryPoint()
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          val3.transforms = []
          for i in range(0, length):
            val4 = geometry_msgs.msg.Transform()
            _v110 = val4.translation
            _x = _v110
            start = end
            end += 24
            (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
            _v111 = val4.rotation
            _x = _v111
            start = end
            end += 32
            (_x.x, _x.y, _x.z, _x.w,) = _struct_4d.unpack(str[start:end])
            val3.transforms.append(val4)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          val3.velocities = []
          for i in range(0, length):
            val4 = geometry_msgs.msg.Twist()
            _v112 = val4.linear
            _x = _v112
            start = end
            end += 24
            (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
            _v113 = val4.angular
            _x = _v113
            start = end
            end += 24
            (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
            val3.velocities.append(val4)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          val3.accelerations = []
          for i in range(0, length):
            val4 = geometry_msgs.msg.Twist()
            _v114 = val4.linear
            _x = _v114
            start = end
            end += 24
            (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
            _v115 = val4.angular
            _x = _v115
            start = end
            end += 24
            (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
            val3.accelerations.append(val4)
          _v116 = val3.time_from_start
          _x = _v116
          start = end
          end += 8
          (_x.secs, _x.nsecs,) = _struct_2i.unpack(str[start:end])
          _v107.points.append(val3)
        self.trajectory.append(val1)
      _x = self
      start = end
      end += 12
      (_x.trajectory_start.joint_state.header.seq, _x.trajectory_start.joint_state.header.stamp.secs, _x.trajectory_start.joint_state.header.stamp.nsecs,) = _struct_3I.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.trajectory_start.joint_state.header.frame_id = str[start:end].decode('utf-8')
      else:
        self.trajectory_start.joint_state.header.frame_id = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.trajectory_start.joint_state.name = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8')
        else:
          val1 = str[start:end]
        self.trajectory_start.joint_state.name.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.trajectory_start.joint_state.position = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.trajectory_start.joint_state.velocity = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.trajectory_start.joint_state.effort = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      _x = self
      start = end
      end += 12
      (_x.trajectory_start.multi_dof_joint_state.header.seq, _x.trajectory_start.multi_dof_joint_state.header.stamp.secs, _x.trajectory_start.multi_dof_joint_state.header.stamp.nsecs,) = _struct_3I.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.trajectory_start.multi_dof_joint_state.header.frame_id = str[start:end].decode('utf-8')
      else:
        self.trajectory_start.multi_dof_joint_state.header.frame_id = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.trajectory_start.multi_dof_joint_state.joint_names = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8')
        else:
          val1 = str[start:end]
        self.trajectory_start.multi_dof_joint_state.joint_names.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.trajectory_start.multi_dof_joint_state.transforms = []
      for i in range(0, length):
        val1 = geometry_msgs.msg.Transform()
        _v117 = val1.translation
        _x = _v117
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
        _v118 = val1.rotation
        _x = _v118
        start = end
        end += 32
        (_x.x, _x.y, _x.z, _x.w,) = _struct_4d.unpack(str[start:end])
        self.trajectory_start.multi_dof_joint_state.transforms.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.trajectory_start.multi_dof_joint_state.twist = []
      for i in range(0, length):
        val1 = geometry_msgs.msg.Twist()
        _v119 = val1.linear
        _x = _v119
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
        _v120 = val1.angular
        _x = _v120
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
        self.trajectory_start.multi_dof_joint_state.twist.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.trajectory_start.multi_dof_joint_state.wrench = []
      for i in range(0, length):
        val1 = geometry_msgs.msg.Wrench()
        _v121 = val1.force
        _x = _v121
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
        _v122 = val1.torque
        _x = _v122
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
        self.trajectory_start.multi_dof_joint_state.wrench.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.trajectory_start.attached_collision_objects = []
      for i in range(0, length):
        val1 = moveit_msgs.msg.AttachedCollisionObject()
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.link_name = str[start:end].decode('utf-8')
        else:
          val1.link_name = str[start:end]
        _v123 = val1.object
        _v124 = _v123.header
        start = end
        end += 4
        (_v124.seq,) = _struct_I.unpack(str[start:end])
        _v125 = _v124.stamp
        _x = _v125
        start = end
        end += 8
        (_x.secs, _x.nsecs,) = _struct_2I.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v124.frame_id = str[start:end].decode('utf-8')
        else:
          _v124.frame_id = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v123.id = str[start:end].decode('utf-8')
        else:
          _v123.id = str[start:end]
        _v126 = _v123.type
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v126.key = str[start:end].decode('utf-8')
        else:
          _v126.key = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v126.db = str[start:end].decode('utf-8')
        else:
          _v126.db = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v123.primitives = []
        for i in range(0, length):
          val3 = shape_msgs.msg.SolidPrimitive()
          start = end
          end += 1
          (val3.type,) = _struct_B.unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          pattern = '<%sd'%length
          start = end
          end += struct.calcsize(pattern)
          val3.dimensions = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
          _v123.primitives.append(val3)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v123.primitive_poses = []
        for i in range(0, length):
          val3 = geometry_msgs.msg.Pose()
          _v127 = val3.position
          _x = _v127
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
          _v128 = val3.orientation
          _x = _v128
          start = end
          end += 32
          (_x.x, _x.y, _x.z, _x.w,) = _struct_4d.unpack(str[start:end])
          _v123.primitive_poses.append(val3)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v123.meshes = []
        for i in range(0, length):
          val3 = shape_msgs.msg.Mesh()
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          val3.triangles = []
          for i in range(0, length):
            val4 = shape_msgs.msg.MeshTriangle()
            start = end
            end += 12
            val4.vertex_indices = numpy.frombuffer(str[start:end], dtype=numpy.uint32, count=3)
            val3.triangles.append(val4)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          val3.vertices = []
          for i in range(0, length):
            val4 = geometry_msgs.msg.Point()
            _x = val4
            start = end
            end += 24
            (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
            val3.vertices.append(val4)
          _v123.meshes.append(val3)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v123.mesh_poses = []
        for i in range(0, length):
          val3 = geometry_msgs.msg.Pose()
          _v129 = val3.position
          _x = _v129
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
          _v130 = val3.orientation
          _x = _v130
          start = end
          end += 32
          (_x.x, _x.y, _x.z, _x.w,) = _struct_4d.unpack(str[start:end])
          _v123.mesh_poses.append(val3)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v123.planes = []
        for i in range(0, length):
          val3 = shape_msgs.msg.Plane()
          start = end
          end += 32
          val3.coef = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=4)
          _v123.planes.append(val3)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v123.plane_poses = []
        for i in range(0, length):
          val3 = geometry_msgs.msg.Pose()
          _v131 = val3.position
          _x = _v131
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
          _v132 = val3.orientation
          _x = _v132
          start = end
          end += 32
          (_x.x, _x.y, _x.z, _x.w,) = _struct_4d.unpack(str[start:end])
          _v123.plane_poses.append(val3)
        start = end
        end += 1
        (_v123.operation,) = _struct_b.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.touch_links = []
        for i in range(0, length):
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val2 = str[start:end].decode('utf-8')
          else:
            val2 = str[start:end]
          val1.touch_links.append(val2)
        _v133 = val1.detach_posture
        _v134 = _v133.header
        start = end
        end += 4
        (_v134.seq,) = _struct_I.unpack(str[start:end])
        _v135 = _v134.stamp
        _x = _v135
        start = end
        end += 8
        (_x.secs, _x.nsecs,) = _struct_2I.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v134.frame_id = str[start:end].decode('utf-8')
        else:
          _v134.frame_id = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v133.joint_names = []
        for i in range(0, length):
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val3 = str[start:end].decode('utf-8')
          else:
            val3 = str[start:end]
          _v133.joint_names.append(val3)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v133.points = []
        for i in range(0, length):
          val3 = trajectory_msgs.msg.JointTrajectoryPoint()
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          pattern = '<%sd'%length
          start = end
          end += struct.calcsize(pattern)
          val3.positions = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          pattern = '<%sd'%length
          start = end
          end += struct.calcsize(pattern)
          val3.velocities = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          pattern = '<%sd'%length
          start = end
          end += struct.calcsize(pattern)
          val3.accelerations = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          pattern = '<%sd'%length
          start = end
          end += struct.calcsize(pattern)
          val3.effort = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
          _v136 = val3.time_from_start
          _x = _v136
          start = end
          end += 8
          (_x.secs, _x.nsecs,) = _struct_2i.unpack(str[start:end])
          _v133.points.append(val3)
        start = end
        end += 8
        (val1.weight,) = _struct_d.unpack(str[start:end])
        self.trajectory_start.attached_collision_objects.append(val1)
      start = end
      end += 1
      (self.trajectory_start.is_diff,) = _struct_B.unpack(str[start:end])
      self.trajectory_start.is_diff = bool(self.trajectory_start.is_diff)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e) #most likely buffer underfill

_struct_I = genpy.struct_I
_struct_B = struct.Struct("<B")
_struct_d = struct.Struct("<d")
_struct_2i = struct.Struct("<2i")
_struct_3I = struct.Struct("<3I")
_struct_b = struct.Struct("<b")
_struct_4d = struct.Struct("<4d")
_struct_2I = struct.Struct("<2I")
_struct_3d = struct.Struct("<3d")
